# -*- coding: utf-8 -*-
"""opti combi - projet square root rank.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZXNhyCQTIiKr94WOZSZOJ12rXZs8HsnT
"""

import numpy as np
from scipy.linalg import circulant
#%%
def matrices1_ledm(n):
    M = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            M[i, j] = (i - j) ** 2
    return M

def matrices2_slackngon(n):
    M = circulant(np.cos(np.pi / n) - np.cos(np.pi / n + 2 * np.pi * np.arange(0, n, 1) / n))
    M /= M[0, 2]
    M = np.maximum(M, 0)
    for i in range(n):
        M[i, i] = 0
        if i < n - 1:
            M[i, i + 1] = 0
        else:
            M[i, 0] = 0
    return M

def fobj(M, P, tol=1e-14):
    sing_values = np.linalg.svd(P * np.sqrt(M), compute_uv=False)  # Valeurs singulières
    ind_nonzero = np.where(sing_values > tol)[0]                  # Indices > tolérance
    return len(ind_nonzero), sing_values[ind_nonzero[-1]]         # Retourne rang et petite valeur singulière

def calculate_rank(P, M):
    """Calcule le rang de la matrice P ∘ M."""
    return np.linalg.matrix_rank(P * M)
#%%
def generate_neighbors(P, neighborhood, num_neighbors=1000):
    """Génère des voisins à partir de la solution actuelle P."""
    neighbors = []
    m, n = P.shape

    for _ in range(num_neighbors):
        P_new = P.copy()

        if neighborhood == 1:  # Modifier un seul élément
            i, j = np.random.randint(0, m), np.random.randint(0, n)
            P_new[i, j] *= -1

        elif neighborhood == 2:  # Modifier une ligne complète
            i = np.random.randint(0, m)
            P_new[i, :] *= -1

        elif neighborhood == 3:  # Modifier une colonne complète
            j = np.random.randint(0, n)
            P_new[:, j] *= -1

        elif neighborhood == 4:  # Modifier plusieurs éléments aléatoires
            num_changes = np.random.randint(1, m * n // 4)  # Modifier jusqu'à 25% des éléments
            for _ in range(num_changes):
                i, j = np.random.randint(0, m), np.random.randint(0, n)
                P_new[i, j] *= -1

        neighbors.append(P_new)

    return neighbors



#%%
def compareP1betterthanP2(M, P1, P2):
    r1, s1 = fobj(M, P1)  # Objectifs pour P1
    r2, s2 = fobj(M, P2)  # Objectifs pour P2
    if r1 != r2:
        return r1 < r2    # Priorité au rang
    return s1 < s2        # Ensuite à la plus petite valeur singulière

def metaheuristic(M, max_iter=100, tabu_size=10):
    """Recherche à voisinage variable pour minimiser le rang de P ∘ M."""
    m, n = M.shape
    P_best = np.ones((m, n))  # Initialisation avec P composé de +1
    rank_best = calculate_rank(P_best, M)  # Rang initial

    for iteration in range(max_iter):
        for neighborhood in range(1, 5):  # Explorer 4 types de voisinage
            neighbors = generate_neighbors(P_best, neighborhood,100)
            sprime = neighbors[np.random.randint(0, 100)]
            neighbors = generate_neighbors(sprime, neighborhood,1000)

            for P_candidate in neighbors:
                if compareP1betterthanP2(M,P_candidate,P_best):
                    P_best = P_candidate
                    break  # Sortir pour explorer à nouveau à partir de cette meilleure solution

    return P_best



#%%
# Exemple d'utilisation
M = np.array([[4, 0, 1], [1, 1, 1], [1, 1, 0]])
M = matrices2_slackngon(7)
best_pattern = metaheuristic(M)
print("Best pattern found:")
print(best_pattern)
#%%
print("Objective:", fobj(M, best_pattern))
