# -*- coding: utf-8 -*-
"""opti combi - projet square root rank.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZXNhyCQTIiKr94WOZSZOJ12rXZs8HsnT
"""
"""
import numpy as np

def matrices1_ledm(n):
  M  = np.zeros((n,n))
  for i in range(n):
    for j in range(n):
      M[i,j]=(i-j)**2
  return M

from scipy.linalg import circulant
def matrices2_slackngon(n):
  M  = circulant(np.cos(np.pi/n)-np.cos(np.pi/n + 2*np.pi*np.arange(0,n,1)/n))
  M /= M[0,2]
  M  = np.maximum(M,0)
  for i in range(n):
    M[i,i] = 0
    if i<n-1:
      M[i,i+1] = 0
    else:
      M[i,0] = 0
  return M

def fobj(M,P,tol=1e-14):
  sing_values = np.linalg.svd(P*np.sqrt(M), compute_uv=False) # Calcul des valeurs singulières de la matrice P.*sqrt(M)
  ind_nonzero = np.where(sing_values > tol)[0]                # indices des valeurs > tolérance donnée
  return len(ind_nonzero), sing_values[ind_nonzero[-1]]       # on retourne objectif1=rang et objectif2=plus petite val sing. non-nulle

def compareP1betterthanP2(M,P1,P2):
  r1, s1 = fobj(M,P1) #on récupère les deux objectifs pour le pattern P1
  r2, s2 = fobj(M,P2) #on récupère les deux objectifs pour le pattern P2
  if r1 != r2:        #on traite les objectifs de façon lexicographique :
      return r1 < r2  # d'abord les valeurs du rang, et si celles-ci sont égales
  return s1 < s2      # alors on prend en compte la valeur de la + petite valeur singulière

def metaheuristic(M):
  bestPattern = np.ones(M.shape) #pattern initial

  ... #votre méthode

  return bestPattern

M = np.array([[4,0,1],[1,1,1],[1,1,0]])
P1 = np.array([[1,1,-1],[-1,1,1],[1,-1,-1]])
P2 = np.array([[-1,1,-1],[-1,-1,1],[1,1,-1]])
print(compareP1betterthanP2(M,P1,P2))
print(np.linalg.svd(P1*np.sqrt(M), compute_uv=False))

M = matrices2_slackngon(7)
P = np.array([[1,1,1,1,1,-1,1],[1,1,1,-1,1,-1,1],[1,1,1,1,1,1,-1],[1,-1,1,1,1,-1,-1],[1,1,-1,1,1,1,1],[1,-1,1,-1,-1,1,1],[1,1,1,1,1,1,1]])
print(fobj(M,P))
"""


import numpy as np
from scipy.linalg import circulant

def matrices1_ledm(n):
    M = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            M[i, j] = (i - j) ** 2
    return M

def matrices2_slackngon(n):
    M = circulant(np.cos(np.pi / n) - np.cos(np.pi / n + 2 * np.pi * np.arange(0, n, 1) / n))
    M /= M[0, 2]
    M = np.maximum(M, 0)
    for i in range(n):
        M[i, i] = 0
        if i < n - 1:
            M[i, i + 1] = 0
        else:
            M[i, 0] = 0
    return M

def fobj(M, P, tol=1e-14):
    sing_values = np.linalg.svd(P * np.sqrt(M), compute_uv=False)  # Valeurs singulières
    ind_nonzero = np.where(sing_values > tol)[0]                  # Indices > tolérance
    return len(ind_nonzero), sing_values[ind_nonzero[-1]]         # Retourne rang et petite valeur singulière

def compareP1betterthanP2(M, P1, P2):
    r1, s1 = fobj(M, P1)  # Objectifs pour P1
    r2, s2 = fobj(M, P2)  # Objectifs pour P2
    if r1 != r2:
        return r1 < r2    # Priorité au rang
    return s1 < s2        # Ensuite à la plus petite valeur singulière


def generate_neighbors(P, n, m):

   #Génère des voisins en inversant les signes de certains éléments de P.
    
    neighbors = []
    for i in range(P.shape[0]):
        for j in range(P.shape[1]):
            neighbor = P.copy()
            neighbor[i, j] *= -1
            neighbors.append(neighbor)
    return neighbors

 
"""    
from itertools import combinations

def generate_neighbors(P, N, M):
    neighbors = []


    # Vérifier que N est valide (inférieur ou égal au nombre d'éléments dans la matrice)
    if N > P.size:
        raise ValueError(f"N ne peut pas être supérieur à {P.size}, le nombre total d'éléments dans la matrice.")


    # Générer toutes les positions (i, j) dans la matrice P
    indices = [(i, j) for i in range(P.shape[0]) for j in range(P.shape[1])]
    
    Tot_elem_to_change = int(np.log2(np.abs(N*M - 122)))
    
    # Générer toutes les combinaisons de N indices
    index_combinations = combinations(indices, Tot_elem_to_change)
    
    # Pour chaque combinaison d'indices, créer un voisin
    for indices_to_change in index_combinations:
        neighbor = P.copy()  # Créer une copie de la matrice P
        for (i, j) in indices_to_change:
            neighbor[i, j] *= -1  # Inverser l'élément à la position (i, j)
        neighbors.append(neighbor)  # Ajouter le voisin à la liste
    
    return neighbors
"""

def metaheuristic(M, max_iter=50, tabu_size=45):
    """
    Métaheuristique basée sur l'algorithme Tabou pour résoudre le problème du square root rank.
    """
    data = []  # Collecte des métriques pour le suivi
    bestPattern = np.ones(M.shape)  # Pattern initial
    tabu_list = []                 # Liste tabou
    best_objective = fobj(M, bestPattern)  # Objectif initial
    currentPattern = bestPattern.copy()

    m, n = np.shape(M)
    
    for iteration in range(max_iter):
        
        neighbors = generate_neighbors(currentPattern, n, m)  # Génère des voisins
        best_neighbor = None
        best_neighbor_objective = None

        for neighbor in neighbors:
            if any(np.array_equal(neighbor, tabu) for tabu in tabu_list):
                continue  # Ignore les voisins dans la liste tabou

            neighbor_objective = fobj(M, neighbor)
            data.append((iteration, neighbor_objective[0], neighbor_objective[1]))
            if best_neighbor is None or compareP1betterthanP2(M, neighbor, best_neighbor):
                best_neighbor = neighbor
                best_neighbor_objective = neighbor_objective

        if best_neighbor is None:
            break  # Aucun voisin valide trouvé

        currentPattern = best_neighbor

        # Mise à jour du meilleur résultat
        if compareP1betterthanP2(M, currentPattern, bestPattern):
            bestPattern = currentPattern
            best_objective = best_neighbor_objective

        # Mise à jour de la liste tabou
        tabu_list.append(currentPattern)
        if len(tabu_list) > tabu_size:
            tabu_list.pop(0)

        print(f"Iteration {iteration + 1}: Best rank so far: {best_objective[0]}")

    return bestPattern, data

def lecture_fichier(path):
    with open(path, 'r') as fin:  # ouverture du fichier en mode lecture
        m, n = map(int, fin.readline().rstrip().split())  # lecture des dimensions m et n
        data = []  # initialisation d'une liste pour stocker les matrices
        
        # Lecture des lignes suivantes contenant les éléments de la matrice
        for _ in range(m):
            ligne = list(map(float, fin.readline().rstrip().split()))  
            data.append(ligne)  
        
    return np.array(data)   # Renvoie la matrice sous forme de tableau numpy

def ecriture_fichier(path, P, valeurs_sing):
    with open(path, 'w') as fout:
        # Écrire le pattern ligne par ligne
        for ligne in P:
            fout.write(' '.join(map(str, ligne)) + '\n')

        # Écrire les valeurs singulières non nulles
        for val in valeurs_sing:
            fout.write(f"{val}\n")

def random_matrix(m, n, r):
    return ((np.random.rand(m, r) * 10) @ (np.random.rand(r, n) * 10)) ** 2


import matplotlib.pyplot as plt
def plot(grasp_data):
    cols, rangs, val_sings = zip(*grasp_data)
    plt.figure(figsize=(12, 6))
    plt.subplot(1, 2, 1)
    plt.plot(cols, rangs, label='Rang')
    plt.xlabel('Colonnes')
    plt.ylabel('Rang')
    plt.title('Évolution du Rang (TABU)')
    plt.grid()
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.plot(cols, val_sings, color='orange', label='Valeur singulière')
    plt.xlabel('Colonnes')
    plt.ylabel('Dernière Valeur Singulière')
    plt.title('Évolution de la Valeur Singulière (GRASP)')
    plt.grid()
    plt.legend()
    plt.tight_layout()
    plt.show()


m = 120
n = 120
r = 8

# Exemple d'utilisation
# Générer la matrice ou lire depuis un fichier
#M = random_matrix(m,n,r) # Exemple de matrice aléatoire
#M = lecture_fichier('correl5_matrice.txt')
#M = lecture_fichier('ledm6_matrice.txt')
#M = lecture_fichier('exempleslide_matrice.txt')
M = lecture_fichier('synthetic_matrice.txt')
#M = matrices1_ledm(20)
#M = lecture_fichier('120.txt')
best_pattern, data = metaheuristic(M)
# Tracer les métriques
plot(data)
print("Best pattern found:")
print(best_pattern, '\n')
print(f"Meilleur rang = {fobj(M, best_pattern)[0]} \n")
print(f"Meilleure valeur singuliere = {fobj(M, best_pattern)[0]}\n")
